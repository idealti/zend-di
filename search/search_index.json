{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"zend-di zend-di provides autowiring to implement Inversion of Control (IoC) containers. IoC containers are widely used to create object instances that have all dependencies resolved and injected. Dependency Injection containers are one form of IoC \u2013 but not the only form. zend-di is designed to be simple, fast and reusable. It provides the following features: Constructor injection Autowiring: Recursively through all dependencies With configured type preferences with configured injections With injections passed in the create() call Code generators to create factories usable by other IoC containers like Zend\\ServiceManager It does not provide: Setter, interface, property or any other injection method than constructor injection Support for factories Declaring shared/unshared instances the injector always creates new instances the default container always shares instances Support for variadic arguments in __construct If you need these features combine it with another IoC container such as zend-servicemanager . File issues at https://github.com/zendframework/zend-di/issues Documentation is at https://docs.zendframework.com/zend-di/","title":"Home"},{"location":"#zend-di","text":"zend-di provides autowiring to implement Inversion of Control (IoC) containers. IoC containers are widely used to create object instances that have all dependencies resolved and injected. Dependency Injection containers are one form of IoC \u2013 but not the only form. zend-di is designed to be simple, fast and reusable. It provides the following features: Constructor injection Autowiring: Recursively through all dependencies With configured type preferences with configured injections With injections passed in the create() call Code generators to create factories usable by other IoC containers like Zend\\ServiceManager It does not provide: Setter, interface, property or any other injection method than constructor injection Support for factories Declaring shared/unshared instances the injector always creates new instances the default container always shares instances Support for variadic arguments in __construct If you need these features combine it with another IoC container such as zend-servicemanager . File issues at https://github.com/zendframework/zend-di/issues Documentation is at https://docs.zendframework.com/zend-di/","title":"zend-di"},{"location":"codegen/","text":"Code Generator zend-di comes with Ahead-of-Time (AoT) generators to create optimized code for production. These generators will inspect the provided classes, resolve their dependencies, and generate factories based on these results. Removal of zend-code dependencies Before version 3.1, this feature required zend-code , which you can add to your project using Composer: $$$$FENCED_CODE_BLOCK_5dfdc71887e825.64156238 Since version 3.1 and up, this is no longer required. Generating an optimized injector The Zend\\Di\\CodeGenerator\\InjectorGenerator class offers an implementation to generate an optimized injector based on the runtime configuration and a resolver instance. use Zend\\Di\\Config; use Zend\\Di\\Definition\\RuntimeDefinition; use Zend\\Di\\Resolver\\DependencyResolver; use Zend\\Di\\CodeGenerator\\InjectorGenerator; $config = new Config(); $resolver = new DependencyResolver(new RuntimeDefinition(), $config) $generator = new InjectorGenerator($config, $resolver); // It is highly recommended to set the container that is used at runtime: $resolver->setContainer($container); $generator->setOutputDirectory('/path/to/generated/files'); $generator->generate([ MyClassA::class, MyClassB::class, // ... ]); You can also utilize Zend\\Code\\Scanner to scan your code for classes: $scanner = new DirectoryScanner(__DIR__); $generator->generate($scanner->getClassNames()); MVC and Expressive integration When you are using zend-di's ConfigProvider with Expressive or consuming the Module class via zend-mvc, you can obtain the generator instance from the service manager: $generator = $serviceManager->get(\\Zend\\Di\\CodeGenerator\\InjectorGenerator::class); AoT Config Options The service factory uses options in your config service, located under the key dependencies.auto.aot . This should be defined as an associative array of options for creating the code generator instance. This array respects the following keys (unknown keys are ignored): namespace : This will be used as base namespace to prefix the namespace of the generated classes. It will be passed to the constructor of Zend\\Di\\CodeGenerator\\InjectorGenerator ; the default value is Zend\\Di\\Generated . directory : The directory where the generated PHP files will be stored. If this value is not provided, you will need to set it with the generator's setOutputDirectory() method before calling generate() . Below is an example detailing configuration of the generator factory: return [ 'dependencies' => [ 'auto' => [ 'aot' => [ 'namespace' => 'AppAoT\\Generated', 'directory' => __DIR__ . '/../gen', ], ], ], ]; Logging The InjectorGenerator allows passing a PSR-3 logger instance via an optional fourth constructor parameter. The generator will log the following information: When a factory is about to be generated for a class or alias (Log level: Debug) When the factory generation caused an exception (Log level: Error)","title":"Code Generator"},{"location":"codegen/#code-generator","text":"zend-di comes with Ahead-of-Time (AoT) generators to create optimized code for production. These generators will inspect the provided classes, resolve their dependencies, and generate factories based on these results.","title":"Code Generator"},{"location":"codegen/#generating-an-optimized-injector","text":"The Zend\\Di\\CodeGenerator\\InjectorGenerator class offers an implementation to generate an optimized injector based on the runtime configuration and a resolver instance. use Zend\\Di\\Config; use Zend\\Di\\Definition\\RuntimeDefinition; use Zend\\Di\\Resolver\\DependencyResolver; use Zend\\Di\\CodeGenerator\\InjectorGenerator; $config = new Config(); $resolver = new DependencyResolver(new RuntimeDefinition(), $config) $generator = new InjectorGenerator($config, $resolver); // It is highly recommended to set the container that is used at runtime: $resolver->setContainer($container); $generator->setOutputDirectory('/path/to/generated/files'); $generator->generate([ MyClassA::class, MyClassB::class, // ... ]); You can also utilize Zend\\Code\\Scanner to scan your code for classes: $scanner = new DirectoryScanner(__DIR__); $generator->generate($scanner->getClassNames());","title":"Generating an optimized injector"},{"location":"codegen/#mvc-and-expressive-integration","text":"When you are using zend-di's ConfigProvider with Expressive or consuming the Module class via zend-mvc, you can obtain the generator instance from the service manager: $generator = $serviceManager->get(\\Zend\\Di\\CodeGenerator\\InjectorGenerator::class);","title":"MVC and Expressive integration"},{"location":"codegen/#logging","text":"The InjectorGenerator allows passing a PSR-3 logger instance via an optional fourth constructor parameter. The generator will log the following information: When a factory is about to be generated for a class or alias (Log level: Debug) When the factory generation caused an exception (Log level: Error)","title":"Logging"},{"location":"config/","text":"Configuration Configuration detailing how types are constructed and dependencies should be resolved can be provided as an associative array when instantiating Zend\\Di\\Config . A type may be an actual class name or an alias to a class name. The configuration array respects the following keys (unknown keys are ignored): preferences : Associative nested array that maps class or interface names to a service name that should be used to provide a dependency. See the Type Preferences section below for details. types : Associative array defining how classes or aliases should be constructed. Each key in this array is a class or alias name, and its value is another associative array with the following keys: preferences : The same as preferences above, but only for the associated class. parameters : Associative array declaring the values to inject for the declared construction parameters. Each key is the parameter name as declared in the constructor method of the associated class name. See the Parameters section below for details. typeOf : String that contains a class name. It declares that the associated key is an alias of the given class name. This class must exist. It cannot not be another alias. Below is an example of injector configuration. $config = new \\Zend\\Di\\Config([ // Declares global preferences to use when resolving // dependencies of the specified type 'preferences' => [ // A map of classname => preferred type MyInterface::class => MyImplementation::class, ], // Declares how types should be constructed. // This also allows declaring aliases of a specific class 'types' => [ ClassName::class => [ // Declaration in the same way as global preferences // but these will aply when the type of the associated key // should be instanciated 'preferences' => [], // Constructor parameters to inject. This option will define // the injections directly by the parameter name of the constructor // used as key. // // If the parameter is type-hinted by a class/interface name, you can // provide the injection by string. The injector will use the IoC // container to obtain it. 'parameters' => [ 'foo' => 'bar', ], ], // Define an alias 'Alias.Name' => [ 'typeOf' => ClassName::class, 'preferences' => [], 'parameters' => [], ], ], ]); Type Preferences In many cases, you might be using interfaces as type hints as opposed to concrete types. Even though type preferences are not limited to interfaces or abstract class names, they provide hints to the injector on how such types should be resolved. The resolver will look up the name finally passed to the container in the following way (the first match will be used): The preference defined in the type configuration of the class if it satifies the typehint (implements, extends, or typeOf). If there is a global preference defined and it satisfies the typehint. Use the typehinted name directly. // Assume the following classes are declared: interface FooInterface {} class Foo implements FooInterface {} class SpecialFoo implements FooInterface {} class Bar {} class MyClass { public function __construct(FooInterface $foo) { // ... } } // With the following configuration: use Zend\\Di\\Injector; use Zend\\Di\\Config; $injector = new Injector(new Config([ 'preferences' => [ FooInterface::class => Foo::class, ], 'types' => [ 'MyClass.A' => [ 'typeOf' => MyClass::class 'preferences' => [ FooInterface::class => SpecialFoo::class,, ], ], 'MyClass.B' => [ 'typeOf' => MyClass::class 'preferences' => [ FooInterface::class => Bar::class,, ], ], ], ]); // The results are: $a = $injector->create(MyClass::class); // Constructed with Foo $b = $injector->create('MyClass.A'); // Constructed with SpecialFoo $c = $injector->create('MyClass.B'); // Constructed with Foo (since Bar does not satisfy FooInterface) Parameters In contrast to type preferences, the resolver will not perform checks if the provided value satisfies the required type. It will be used directly to inject the value. There are several ways to define injections. An IoC container service name as string: This is only possible if the required type is a class or interface. For other types (scalars, iterable , callable , etc) or typeless parameters, the string value is passed as is . An instance of Zend\\Di\\Resolver\\ValueInjection : Injects the value returned by getValue() as is. An instance of Zend\\Di\\Resolver\\TypeInjection : Obtains the injected value from the IoC container by passing the return value of getType() to the container's get() method. The string literal '*' : This requests the injector to ignore any previously defined parameter and use the type preference resolution as described in Type Preferences . Any other value will be used as is and encapsulated in a Zend\\Di\\Resolver\\ValueInjection . If the provided value's type does not fit the required parameter type, an exception is thrown. Aliases Aliases allow you to configure the same class with different construction options. Aliases can directly be created with the injector or declared as type preferences. An alias must refer to an actual class or an interface, therefore you cannot declare aliases for another alias. For example the following the following class should be instantiated in two different ways: // Assume the following classes are declared: class Foo {} class SpecialFoo extends Foo {} class MyClass { public function __construct(Foo $foo, string $bar) { // ... } } // With the following injection config: use Zend\\Di\\Injector; use Zend\\Di\\Config; $injector = new Injector(new Config([ 'types' => [ MyClass::class => [ 'parameters' => [ 'foo' => SpecialFoo::class, 'bar' => 'Stringvalue', ], ], 'MyClass.Alias' => [ 'typeOf' => MyClass::class, 'parameters' => [ 'foo' => '*', 'bar' => 'Stringvalue', ], ], ], ]); // The results are: $a = $injector->create(MyClass::class); // Constructed with SpecialFoo $b = $injector->create('MyClass.Alias'); // Constructed with Foo (since there are no type preferences for Foo)","title":"Configuration"},{"location":"config/#configuration","text":"Configuration detailing how types are constructed and dependencies should be resolved can be provided as an associative array when instantiating Zend\\Di\\Config . A type may be an actual class name or an alias to a class name. The configuration array respects the following keys (unknown keys are ignored): preferences : Associative nested array that maps class or interface names to a service name that should be used to provide a dependency. See the Type Preferences section below for details. types : Associative array defining how classes or aliases should be constructed. Each key in this array is a class or alias name, and its value is another associative array with the following keys: preferences : The same as preferences above, but only for the associated class. parameters : Associative array declaring the values to inject for the declared construction parameters. Each key is the parameter name as declared in the constructor method of the associated class name. See the Parameters section below for details. typeOf : String that contains a class name. It declares that the associated key is an alias of the given class name. This class must exist. It cannot not be another alias. Below is an example of injector configuration. $config = new \\Zend\\Di\\Config([ // Declares global preferences to use when resolving // dependencies of the specified type 'preferences' => [ // A map of classname => preferred type MyInterface::class => MyImplementation::class, ], // Declares how types should be constructed. // This also allows declaring aliases of a specific class 'types' => [ ClassName::class => [ // Declaration in the same way as global preferences // but these will aply when the type of the associated key // should be instanciated 'preferences' => [], // Constructor parameters to inject. This option will define // the injections directly by the parameter name of the constructor // used as key. // // If the parameter is type-hinted by a class/interface name, you can // provide the injection by string. The injector will use the IoC // container to obtain it. 'parameters' => [ 'foo' => 'bar', ], ], // Define an alias 'Alias.Name' => [ 'typeOf' => ClassName::class, 'preferences' => [], 'parameters' => [], ], ], ]);","title":"Configuration"},{"location":"config/#type-preferences","text":"In many cases, you might be using interfaces as type hints as opposed to concrete types. Even though type preferences are not limited to interfaces or abstract class names, they provide hints to the injector on how such types should be resolved. The resolver will look up the name finally passed to the container in the following way (the first match will be used): The preference defined in the type configuration of the class if it satifies the typehint (implements, extends, or typeOf). If there is a global preference defined and it satisfies the typehint. Use the typehinted name directly. // Assume the following classes are declared: interface FooInterface {} class Foo implements FooInterface {} class SpecialFoo implements FooInterface {} class Bar {} class MyClass { public function __construct(FooInterface $foo) { // ... } } // With the following configuration: use Zend\\Di\\Injector; use Zend\\Di\\Config; $injector = new Injector(new Config([ 'preferences' => [ FooInterface::class => Foo::class, ], 'types' => [ 'MyClass.A' => [ 'typeOf' => MyClass::class 'preferences' => [ FooInterface::class => SpecialFoo::class,, ], ], 'MyClass.B' => [ 'typeOf' => MyClass::class 'preferences' => [ FooInterface::class => Bar::class,, ], ], ], ]); // The results are: $a = $injector->create(MyClass::class); // Constructed with Foo $b = $injector->create('MyClass.A'); // Constructed with SpecialFoo $c = $injector->create('MyClass.B'); // Constructed with Foo (since Bar does not satisfy FooInterface)","title":"Type Preferences"},{"location":"config/#parameters","text":"In contrast to type preferences, the resolver will not perform checks if the provided value satisfies the required type. It will be used directly to inject the value. There are several ways to define injections. An IoC container service name as string: This is only possible if the required type is a class or interface. For other types (scalars, iterable , callable , etc) or typeless parameters, the string value is passed as is . An instance of Zend\\Di\\Resolver\\ValueInjection : Injects the value returned by getValue() as is. An instance of Zend\\Di\\Resolver\\TypeInjection : Obtains the injected value from the IoC container by passing the return value of getType() to the container's get() method. The string literal '*' : This requests the injector to ignore any previously defined parameter and use the type preference resolution as described in Type Preferences . Any other value will be used as is and encapsulated in a Zend\\Di\\Resolver\\ValueInjection . If the provided value's type does not fit the required parameter type, an exception is thrown.","title":"Parameters"},{"location":"config/#aliases","text":"Aliases allow you to configure the same class with different construction options. Aliases can directly be created with the injector or declared as type preferences. An alias must refer to an actual class or an interface, therefore you cannot declare aliases for another alias. For example the following the following class should be instantiated in two different ways: // Assume the following classes are declared: class Foo {} class SpecialFoo extends Foo {} class MyClass { public function __construct(Foo $foo, string $bar) { // ... } } // With the following injection config: use Zend\\Di\\Injector; use Zend\\Di\\Config; $injector = new Injector(new Config([ 'types' => [ MyClass::class => [ 'parameters' => [ 'foo' => SpecialFoo::class, 'bar' => 'Stringvalue', ], ], 'MyClass.Alias' => [ 'typeOf' => MyClass::class, 'parameters' => [ 'foo' => '*', 'bar' => 'Stringvalue', ], ], ], ]); // The results are: $a = $injector->create(MyClass::class); // Constructed with SpecialFoo $b = $injector->create('MyClass.Alias'); // Constructed with Foo (since there are no type preferences for Foo)","title":"Aliases"},{"location":"injector/","text":"Injector The Zend\\Di\\Injector is responsible for creating instances by providing the dependencies required by the class. The dependencies are resolved by analyzing the constructor parameters of the requested class via reflection. For parameters defined with a class or interface typehint, the configured preferences are taken into account. A Zend\\Di\\ConfigInterface can be provided to configure the injector. See the Configuration chapter for details. Create instances Instances can be created by calling create() : use Zend\\Di\\Injector; $injector = new Injector() $injector->create(MyClass::class); Create instances with parameters You can also pass construction parameters when calling create: $injector->create(MyDbAdapter::class, [ 'username' => 'johndoe', ]); Parameters passed to create() will overwrite any configured injection for the requested class. Generally the following behavior applies for parameter values that are not ValueInjection or TypeInjection instances: If the parameter has a class/interface typehint: string values will be wrapped into a TypeInjection instance objects are wrapped into a ValueInjection instance everything else will fail with an exception. If the parameter has a scalar or pseudo-type typehint (e.g. string, int, iterable, callable, etc ...), the value will be wrapped in a ValueInjection . If the parameter has no typehint at all, the value will be wrapped into a ValueInjection . Examples // Assume the following classes class Foo {} class SpecialFoo extends Foo {} class Bar { public function __construct(Foo $foo, $type = null) {} } // Usage use Zend\\Di\\Resolver\\ValueInjection; use Zend\\Di\\Resolver\\TypeInjection; // Creates Bar with an instance of SpecialFoo from the IoC container: $injector->create(Bar::class, [ 'foo' => SpecialFoo::class, ]); // Creates Bar with the given instance of SpecialFoo bypassing the IoC // container: $injector->create(Bar::class, [ 'foo' => ValueInjection(new SpecialFoo()), ]); // Creates Bar with an instance of Foo and the string literal 'SpecialFoo' for // $type: $injector->create(Bar::class, [ 'type' => SpecialFoo::class, ]); // Creates Bar with an instance of Foo and an instance of SpecialFoo from the // IoC container for $type: $injector->create(Bar::class, [ 'type' => new TypeInjection(SpecialFoo::class), ]); Refer to the Parameters section in the Configuration chapter for all possibilities of how parameters can be declared. Check if a type is creatable If you uncertain whether or not the injector can create a specific type, you can test it with the canCreate() method. For example, if you were to consume the class name in a generic service factory for zend-servicemanager: use Zend\\Di\\Injector; /** @var \\Zend\\ServiceManager\\ServiceManager $container */ $factory = function($container, $requestedName, array $options = null) { $injector = $container->get(Injector::class); if (! $injector->canCreate($requestedName)) { throw new \\RuntimeException('Bad service name'); } return $injector->create($requestedName, $options? : []); }; $serviceManager->setFactory('Foo', $factory); $serviceManager->setFactory('Bar', $factory); $serviceManager->setFactory(stdClass::class, $factory);","title":"Injector"},{"location":"injector/#injector","text":"The Zend\\Di\\Injector is responsible for creating instances by providing the dependencies required by the class. The dependencies are resolved by analyzing the constructor parameters of the requested class via reflection. For parameters defined with a class or interface typehint, the configured preferences are taken into account. A Zend\\Di\\ConfigInterface can be provided to configure the injector. See the Configuration chapter for details.","title":"Injector"},{"location":"injector/#create-instances","text":"Instances can be created by calling create() : use Zend\\Di\\Injector; $injector = new Injector() $injector->create(MyClass::class);","title":"Create instances"},{"location":"injector/#create-instances-with-parameters","text":"You can also pass construction parameters when calling create: $injector->create(MyDbAdapter::class, [ 'username' => 'johndoe', ]); Parameters passed to create() will overwrite any configured injection for the requested class. Generally the following behavior applies for parameter values that are not ValueInjection or TypeInjection instances: If the parameter has a class/interface typehint: string values will be wrapped into a TypeInjection instance objects are wrapped into a ValueInjection instance everything else will fail with an exception. If the parameter has a scalar or pseudo-type typehint (e.g. string, int, iterable, callable, etc ...), the value will be wrapped in a ValueInjection . If the parameter has no typehint at all, the value will be wrapped into a ValueInjection .","title":"Create instances with parameters"},{"location":"injector/#check-if-a-type-is-creatable","text":"If you uncertain whether or not the injector can create a specific type, you can test it with the canCreate() method. For example, if you were to consume the class name in a generic service factory for zend-servicemanager: use Zend\\Di\\Injector; /** @var \\Zend\\ServiceManager\\ServiceManager $container */ $factory = function($container, $requestedName, array $options = null) { $injector = $container->get(Injector::class); if (! $injector->canCreate($requestedName)) { throw new \\RuntimeException('Bad service name'); } return $injector->create($requestedName, $options? : []); }; $serviceManager->setFactory('Foo', $factory); $serviceManager->setFactory('Bar', $factory); $serviceManager->setFactory(stdClass::class, $factory);","title":"Check if a type is creatable"},{"location":"intro/","text":"Introduction Dependency Injection Dependency Injection (here-in called DI) refers to the act of providing dependencies for an object during instantiation or via a method call. A basic example looks like this: $b = new MovieLister(new MovieFinder()); Above, MovieFinder is a dependency of MovieLister , and MovieFinder was injected into MovieLister . There are several forms of dependency injection: Constructor injection Setter injection Property (or field) injection While previous versions of zend-di attempted to handle all three types, starting in version 3, the component focuses only on the first, constructor injection. This decision was made for several reasons: It simplified the implementation dramatically. The simplified implementation had performance benefits. It enforces the order of object initialization, which both helps to prevent circular dependencies, and ensures the completeness of the instantiated object. Further reading If you are not familiar with the concept of DI, here are several great reads: Matthew Weier O'Phinney's Analogy Ralph Schindler's Learning DI Fabien Potencier's Series on DI zend-servicemanager Since zend-di purely provides automatic DI (aka auto wiring), it does not provide code-driven Inversion of Control (IoC). However, Zend Framework does ship with another IoC component as well: zend-servicemanager . Unlike zend-di, zend-servicemanager is code-driven, meaning that you tell it what class to instantiate, or provide a factory for the given class. This allows you more fine-grained control on how your objects will be instantiated. In fact zend-di is designed to play nicely with other IoC containers that implement PSR-11, especially with zend-servicemanager. You can even use factories generated by zend-di for zend-servicemanager. Dependency Injection Containers When your code is written in such a way that all your dependencies are injected into consuming objects, you might find that the simple act of wiring an object has gotten more complex. When this becomes the case, and you find that this wiring is creating more boilerplate code, this makes for an excellent opportunity to utilize a Dependency Injection Container. These containers are also often referred to as IoC Containers. In its simplest form, a Dependency Injection Container (here-in called a DiC for brevity) is an object that is capable of creating objects on request and managing the \"wiring\", or the injection of required dependencies, for those requested objects. Since the patterns that developers employ in writing DI capable code vary, DiC's are generally either in the form of smallish objects that suit a very specific pattern, or larger DiC frameworks. The PHP FIG defined a standard interface for such DiCs via PSR-11 (ContainerInterface) . zend-di is a DiC framework which provides an injector performing the wiring, and a simple imlementation of a DiC. The injector is able to consume any PSR-11 container, such as zend-servicemanager , to obtain the instances of the dependencies. While for the simplest use cases no configuration is needed, zend-di allows developers to configure how to resolve dependencies for more complex use cases. Legacy documentation The primary documentation covers version 3.0 and above. We also ship documentation covering version 2 features, starting with a chapter covering zend-di Definition classes .","title":"Introduction"},{"location":"intro/#introduction","text":"","title":"Introduction"},{"location":"intro/#dependency-injection","text":"Dependency Injection (here-in called DI) refers to the act of providing dependencies for an object during instantiation or via a method call. A basic example looks like this: $b = new MovieLister(new MovieFinder()); Above, MovieFinder is a dependency of MovieLister , and MovieFinder was injected into MovieLister . There are several forms of dependency injection: Constructor injection Setter injection Property (or field) injection While previous versions of zend-di attempted to handle all three types, starting in version 3, the component focuses only on the first, constructor injection. This decision was made for several reasons: It simplified the implementation dramatically. The simplified implementation had performance benefits. It enforces the order of object initialization, which both helps to prevent circular dependencies, and ensures the completeness of the instantiated object.","title":"Dependency Injection"},{"location":"intro/#dependency-injection-containers","text":"When your code is written in such a way that all your dependencies are injected into consuming objects, you might find that the simple act of wiring an object has gotten more complex. When this becomes the case, and you find that this wiring is creating more boilerplate code, this makes for an excellent opportunity to utilize a Dependency Injection Container. These containers are also often referred to as IoC Containers. In its simplest form, a Dependency Injection Container (here-in called a DiC for brevity) is an object that is capable of creating objects on request and managing the \"wiring\", or the injection of required dependencies, for those requested objects. Since the patterns that developers employ in writing DI capable code vary, DiC's are generally either in the form of smallish objects that suit a very specific pattern, or larger DiC frameworks. The PHP FIG defined a standard interface for such DiCs via PSR-11 (ContainerInterface) . zend-di is a DiC framework which provides an injector performing the wiring, and a simple imlementation of a DiC. The injector is able to consume any PSR-11 container, such as zend-servicemanager , to obtain the instances of the dependencies. While for the simplest use cases no configuration is needed, zend-di allows developers to configure how to resolve dependencies for more complex use cases.","title":"Dependency Injection Containers"},{"location":"intro/#legacy-documentation","text":"The primary documentation covers version 3.0 and above. We also ship documentation covering version 2 features, starting with a chapter covering zend-di Definition classes .","title":"Legacy documentation"},{"location":"migration/","text":"Migration Guide Version 3 is the first new major release of zend-di, and contains a number of backward incompatible changes. These were introduced to provide better performance, stability, and predictability. This guide describes how to migrate from Version 2 to 3. What has changed? This lists the most impacting changes and potential pitfalls when upgrading to zend-di version 3. The injector now only supports constructor injections. If you require injections based on \"Aware\" interfaces or setter/method injections, you need to provide these on your own. You could do this by decorating the injector instance or using initializers in zend-servicemanager. \\Zend\\Di\\Di is renamed to \\Zend\\Di\\InjectorInterface . It also is no longer an IoC container which offers get() / has() . Container functionality is now provided via Zend\\Di\\DefaultContainer , which implements Psr\\Container\\ContainerInterface . If you were using \\Zend\\Di\\Di as an IoC container, please switch to Zend\\Di\\DefaultContainer or use it with zend-servicemanager . All programmatic and array-based definitions were dropped. If you need custom definitions, implement \\Zend\\Di\\Definition\\DefinitionInterface . The definition compiler was removed in favor of a code generator , which offers better performance. Added PHP 7.1 type safety. All interfaces and classes are strongly typed, and all methods use return typehints, as well as scalar typehints where needed. Generator and GeneratorInstance in Zend\\Di\\ServiceLocator were removed in favor of the code generator , which creates zend-servicemanager compatible factories. Migrating from v2 to v3 with zend-mvc When you are using zend-mvc, you can follow these steps to upgrade: Remove zendframework/zend-servicemanager-di from your composer.json , or execute composer remove zendframework/zend-servicemanager-di . Change the version constraint for zendframework/zend-di to ^3.0 , or execute composer require \"zendframework/zend-di:^3.0\" . Change any remaining module entries for Zend\\ServiceManager\\Di\\Module to Zend\\Di\\Module within either config/application.config.php or config/modules.config.php . If you are using any factories from zend-servicemanager-di, you may have to replace them with Zend\\Di\\Container\\AutowireFactory . Migrate your zend-di config to the new configuration format . Migrating configuration zend-di configuration is now expected in $config['dependencies']['auto'] , where $config is your config service. The zend-di config service factory will automatically attempt to migrate legacy configurations at runtime, which gives you some time to migrate your configs. You can use Zend\\Di\\LegacyConfig to help migrating existing configs: use Zend\\Di\\LegacyConfig; $migrated = new LegacyConfig($diConfigArray); $code = var_export($migrated->toArray(), true); When the zend-di config service factory is used to create configuration for use with the AutowireFactory and/or DefaultContainer , if it detects the $config['di] key, it will emit an E_USER_DEPRECATED error, pointing to this documentation. We recommend using the above approach to convert your configuration to the format recognized by version 3.","title":"Migration Guide"},{"location":"migration/#migration-guide","text":"Version 3 is the first new major release of zend-di, and contains a number of backward incompatible changes. These were introduced to provide better performance, stability, and predictability. This guide describes how to migrate from Version 2 to 3.","title":"Migration Guide"},{"location":"migration/#what-has-changed","text":"This lists the most impacting changes and potential pitfalls when upgrading to zend-di version 3. The injector now only supports constructor injections. If you require injections based on \"Aware\" interfaces or setter/method injections, you need to provide these on your own. You could do this by decorating the injector instance or using initializers in zend-servicemanager. \\Zend\\Di\\Di is renamed to \\Zend\\Di\\InjectorInterface . It also is no longer an IoC container which offers get() / has() . Container functionality is now provided via Zend\\Di\\DefaultContainer , which implements Psr\\Container\\ContainerInterface . If you were using \\Zend\\Di\\Di as an IoC container, please switch to Zend\\Di\\DefaultContainer or use it with zend-servicemanager . All programmatic and array-based definitions were dropped. If you need custom definitions, implement \\Zend\\Di\\Definition\\DefinitionInterface . The definition compiler was removed in favor of a code generator , which offers better performance. Added PHP 7.1 type safety. All interfaces and classes are strongly typed, and all methods use return typehints, as well as scalar typehints where needed. Generator and GeneratorInstance in Zend\\Di\\ServiceLocator were removed in favor of the code generator , which creates zend-servicemanager compatible factories.","title":"What has changed?"},{"location":"migration/#migrating-from-v2-to-v3-with-zend-mvc","text":"When you are using zend-mvc, you can follow these steps to upgrade: Remove zendframework/zend-servicemanager-di from your composer.json , or execute composer remove zendframework/zend-servicemanager-di . Change the version constraint for zendframework/zend-di to ^3.0 , or execute composer require \"zendframework/zend-di:^3.0\" . Change any remaining module entries for Zend\\ServiceManager\\Di\\Module to Zend\\Di\\Module within either config/application.config.php or config/modules.config.php . If you are using any factories from zend-servicemanager-di, you may have to replace them with Zend\\Di\\Container\\AutowireFactory . Migrate your zend-di config to the new configuration format .","title":"Migrating from v2 to v3 with zend-mvc"},{"location":"migration/#migrating-configuration","text":"zend-di configuration is now expected in $config['dependencies']['auto'] , where $config is your config service. The zend-di config service factory will automatically attempt to migrate legacy configurations at runtime, which gives you some time to migrate your configs. You can use Zend\\Di\\LegacyConfig to help migrating existing configs: use Zend\\Di\\LegacyConfig; $migrated = new LegacyConfig($diConfigArray); $code = var_export($migrated->toArray(), true); When the zend-di config service factory is used to create configuration for use with the AutowireFactory and/or DefaultContainer , if it detects the $config['di] key, it will emit an E_USER_DEPRECATED error, pointing to this documentation. We recommend using the above approach to convert your configuration to the format recognized by version 3.","title":"Migrating configuration"},{"location":"psr-11/","text":"PSR-11 Support zend-di supports and implements PSR-11 ContainerInterface starting in version 3. It supports any implementation to obtain instances for resolved dependencies. zend-di ships with a very basic implementation of the container interface which only uses the injector to creates instances and always shares services it creates. We suggest you replace it with another implementation such as zend-servicemanager for more flexibility.","title":"PSR-11 Support"},{"location":"psr-11/#psr-11-support","text":"zend-di supports and implements PSR-11 ContainerInterface starting in version 3. It supports any implementation to obtain instances for resolved dependencies. zend-di ships with a very basic implementation of the container interface which only uses the injector to creates instances and always shares services it creates. We suggest you replace it with another implementation such as zend-servicemanager for more flexibility.","title":"PSR-11 Support"},{"location":"quick-start/","text":"Quick Start The DI component provides an auto wiring strategy which implements constructor injection . It utilizes PSR-11 containers to obtain required services, so it can be paired with any IoC container that implements this interface, such as zend-servicemanager . 1. Installation If you haven't already, install Composer . Once you have, you can install zend-di: $ composer require zendframework/zend-di 2. Configuring the injector You can now create and configure an injector instance. The injector accepts an instance of Zend\\Di\\ConfigInterface . This can be provided by passing Zend\\Di\\Config , which accepts a PHP array to its constructor: use Zend\\Di\\Injector; use Zend\\Di\\Config; $injector = new Injector(new Config([ 'preferences' => [ MyInterface::class => MyImplementation::class, ], ])); This config implementation accepts a veriety of options. Refer to the Configuration chapter for full details. 3. Creating instances Finally, you can create new instances of a specific class or alias by using the create() method: $instance = $injector->create(MyClass::class); The only precondition is that the class you provide to create() must exist (or be autoloadable). If this is not the case, the injector will fail with an exception. The create() method will always create a new instance of the given class. If you need a shared instance, you can associate an IoC container implementing PSR-11 with the injector: $injector = new Injector($config, $container); $sharedInstance = $injector->getContainer()->get(MyClass::class); By default, the injector creates and uses an instance of Zend\\Di\\DefaultContainer if no container is provided to it. This implementation is quite limited, however, and we recommend you use a more featureful container with the injector, such as zend-servicemanager . Refer to the Usage with PSR-11 containers and Usage with zend-servicemanager chapters for details.","title":"Quick Start"},{"location":"quick-start/#quick-start","text":"The DI component provides an auto wiring strategy which implements constructor injection . It utilizes PSR-11 containers to obtain required services, so it can be paired with any IoC container that implements this interface, such as zend-servicemanager .","title":"Quick Start"},{"location":"quick-start/#1-installation","text":"If you haven't already, install Composer . Once you have, you can install zend-di: $ composer require zendframework/zend-di","title":"1. Installation"},{"location":"quick-start/#2-configuring-the-injector","text":"You can now create and configure an injector instance. The injector accepts an instance of Zend\\Di\\ConfigInterface . This can be provided by passing Zend\\Di\\Config , which accepts a PHP array to its constructor: use Zend\\Di\\Injector; use Zend\\Di\\Config; $injector = new Injector(new Config([ 'preferences' => [ MyInterface::class => MyImplementation::class, ], ])); This config implementation accepts a veriety of options. Refer to the Configuration chapter for full details.","title":"2. Configuring the injector"},{"location":"quick-start/#3-creating-instances","text":"Finally, you can create new instances of a specific class or alias by using the create() method: $instance = $injector->create(MyClass::class); The only precondition is that the class you provide to create() must exist (or be autoloadable). If this is not the case, the injector will fail with an exception. The create() method will always create a new instance of the given class. If you need a shared instance, you can associate an IoC container implementing PSR-11 with the injector: $injector = new Injector($config, $container); $sharedInstance = $injector->getContainer()->get(MyClass::class); By default, the injector creates and uses an instance of Zend\\Di\\DefaultContainer if no container is provided to it. This implementation is quite limited, however, and we recommend you use a more featureful container with the injector, such as zend-servicemanager . Refer to the Usage with PSR-11 containers and Usage with zend-servicemanager chapters for details.","title":"3. Creating instances"},{"location":"cookbook/aot-guide/","text":"Using AoT with Expressive and zend-servicemanager This guide will show you how you can use zend-di's Ahead-of-Time (AoT) compiler to make your Expressive application production ready when it uses zend-di. You will learn how to: Add a script to run the compilation. Use the generated injector with zend-servicemanager. Use the generated factories with zend-servicemanager. 1. Create project and add zend-di For this guide, we will use an expressive application built from the skeleton with zend-servicemanager as its IoC container. If you have already set up a project with zend-di, you can skip this step. First, we'll create a new project: $ composer create-project zendframework/zend-expressive-skeleton zend-di-aot-example Pick the components you want to use. We will be using zend-servicemanager and a \"Modular\" layout for this example. Once you are done, enter the newly created project's working directory: $ cd zend-di-aot-example Now add zend-di with composer: $ composer require zendframework/zend-di Possible version conflicts Please make sure that zend-di version 3.x is installed. When you are upgrading from zend-di version 2.x, you may have to remove zend-servicemanager-di because version 3.x makes this package obsolete and therefore conflicts with it. You can ensure version 3.x is installed by adding a version constraint to composer's require command: $$$$FENCED_CODE_BLOCK_5dfdc71887bba1.84082384 This approach will also notify you if there are conflicts with installing v3. Additional requirements for version 3.0.x Before version 3.1, zendframework/zend-code was required to be added individually to your project for generating AoT code. Since version 3.1 this is no longer necessary. The component installer should ask you where to inject the config provider. Pick option 1, which usually is config/config.php . If not, or you cannot use the component installer, you will need to add it manually by adding an entry for \\Zend\\Di\\ConfigProvider::class within your application configuration example: // config/config.php: use Zend\\ConfigAggregator\\ArrayProvider; use Zend\\ConfigAggregator\\ConfigAggregator; use Zend\\ConfigAggregator\\PhpFileProvider; // ... $aggregator = new ConfigAggregator([ // Add Zend\\Di \\Zend\\Di\\ConfigProvider::class, // ... ], $cacheConfig['config_cache_path']); // ... 2. Make your project ready for AoT To follow the modular principle of our expressive app, we will put the AoT related configurations and generated code in a separate module called AppAoT . By default, skeleton applications include the zend-expressive-tooling component, which allows you to do this in a single step: $ ./vendor/bin/expressive module:create AppAoT If the tooling is present and the above command is successful, you can now skip to the next step. Otherwise, continue on to manually create your module. First, create the initial directory structure: $ mkdir src/AppAoT/src Next, create a config provider class in src/AppAoT/src/ConfigProvider.php : namespace AppAoT; class ConfigProvider { public function __invoke() { return [ 'dependencies' => $this->getDependencies(), ]; } public function getDependencies() { return [ 'auto' => [ 'aot' => [ 'namespace' => __NAMESPACE__ . '\\\\Generated', 'directory' => __DIR__ . '/../gen', ], ], ]; } } Add this new class to the the beginning of your config/config.php file's ConfigAggregator settings: $aggregator = new ConfigAggregator([ \\AppAoT\\ConfigProvider::class // Add Zend\\Di \\Zend\\Di\\ConfigProvider::class, // ... ]); In order for your application to find this class, we need to add an autoloading rule. Find the psr-4 autoloader section of your composer.json , and add an entry for your new AppAot namespace as follows: { \"autoload\": { \"psr-4\": { \"App\\\\\": \"src/App/src/\", \"AppAoT\\\\\": \"src/AppAoT/src/\", \"AppAoT\\\\Generated\\\\\": \"src/AppAoT/gen/\" } }, ... } Note that we defined AppAoT\\\\Generated\\\\ which will point to the code we generate from zend-di in the next steps. Finally, update your autoloader: $ composer dump-autoload 3. Add some auto-wiring Because zend-di can provide autowiring for us, we can remove configuration that already exists within our App module. Edit the file src/App/src/ConfigProvider.php and comment out the entries shown below: public function getDependencies() { return [ 'invokables' => [ // Action\\PingAction::class => Action\\PingAction::class, ], 'factories' => [ // Action\\HomePageAction::class => Action\\HomePageFactory::class, ], ]; } We can also now remove the HomePageFactory referenced in that method: $ rm src/App/src/HomePageFactory.php The default actions ( HomePageAction and PingAction ) now use auto wiring! 4. Add a code generator command script We will now add a simple script in the bin/ directory, which we will also add to our composer.json scripts section, to generate factories. In the real world, you might use a console implementation such as symfony/console for scripts such as these. Add the generator script bin/di-generate-aot.php : namespace AppAoT; use Psr\\Container\\ContainerInterface; use Zend\\Code\\Scanner\\DirectoryScanner; use Zend\\Di\\CodeGenerator\\InjectorGenerator; use Zend\\Di\\Config; require __DIR__ . '/../vendor/autoload.php'; // Define the source directories to scan for classes for which // to generate AoT factories: $directories = [ __DIR__ . '/../src/App/src', ]; /** @var ContainerInterface $container */ $container = require __DIR__ . '/../config/container.php'; $scanner = new DirectoryScanner($directories); $generator = $container->get(InjectorGenerator::class); $generator->generate($scanner->getClassNames()); Manually creating a generator instance Before version 3.1, no service factory existed for the generator. Below is an example demonstrating manual creation of the generator: $$$$FENCED_CODE_BLOCK_5dfdc71887c0b4.07599270 To add the Composer script, edit composer.json and add the following to the scripts section: { \"scripts\": { \"di-generate-aot\": [ \"rm -vfr src/AppAoT/gen\", \"php bin/di-generate-aot.php\" ] } } When running the compiler with composer di-generate-aot , it will generate the following files: 5. Add AoT to the service manager Now we need to make the service manager use the AoT code. First, we'll create a delegate factory to decorate the DI injector with the AoT version. Decorating the injector ensures that your factories that utilize Zend\\Di\\Container\\AutowireFactory will benefit from AoT as well. Create the file src/AppAoT/src/InjectorDecoratorFactory.php with the following contents: namespace AppAoT; use AppAoT\\Generated\\GeneratedInjector; use Interop\\Container\\ContainerInterface; use Zend\\ServiceManager\\Factory\\DelegatorFactoryInterface; class InjectorDecoratorFactory implements DelegatorFactoryInterface { public function __invoke(ContainerInterface $container, $name, callable $callback, array $options = null) { $injector = $callback(); if (class_exists(GeneratedInjector::class)) { return new GeneratedInjector($injector); } return $injector; } } After this we need to add configuration to the ConfigProvider class we created in step 2: Important: After this step, the application will always use the generated factories, if present. If you change any dependencies, you will need to run composer di-aot-generation again, or remove the generated code in src/AppAoT/gen/ and use runtime wiring. namespace AppAoT; use Zend\\Di\\InjectorInterface; class ConfigProvider { public function __invoke() { return [ 'dependencies' => $this->getDependencies(), ]; } public function getDependencies() { return [ 'auto' => [ 'aot' => [ 'namespace' => __NAMESPACE__ . '\\\\Generated', 'directory' => __DIR__ . '/../gen', ], ], 'factories' => $this->getGeneratedFactories(), 'delegators' => [ InjectorInterface::class => [ InjectorDecoratorFactory::class, ], ], ]; } private function getGeneratedFactories() { // The generated factories.php file is compatible with // zend-servicemanager's factory configuration. // This avoids using the abstract AutowireFactory, which // improves performance a bit since we spare some lookups. if (file_exists(__DIR__ . '/../gen/factories.php')) { return include __DIR__ . '/../gen/factories.php'; } return []; } }","title":"Using AoT with Expressive and zend-servicemanager"},{"location":"cookbook/aot-guide/#using-aot-with-expressive-and-zend-servicemanager","text":"This guide will show you how you can use zend-di's Ahead-of-Time (AoT) compiler to make your Expressive application production ready when it uses zend-di. You will learn how to: Add a script to run the compilation. Use the generated injector with zend-servicemanager. Use the generated factories with zend-servicemanager.","title":"Using AoT with Expressive and zend-servicemanager"},{"location":"cookbook/aot-guide/#1-create-project-and-add-zend-di","text":"For this guide, we will use an expressive application built from the skeleton with zend-servicemanager as its IoC container. If you have already set up a project with zend-di, you can skip this step. First, we'll create a new project: $ composer create-project zendframework/zend-expressive-skeleton zend-di-aot-example Pick the components you want to use. We will be using zend-servicemanager and a \"Modular\" layout for this example. Once you are done, enter the newly created project's working directory: $ cd zend-di-aot-example Now add zend-di with composer: $ composer require zendframework/zend-di","title":"1. Create project and add zend-di"},{"location":"cookbook/aot-guide/#2-make-your-project-ready-for-aot","text":"To follow the modular principle of our expressive app, we will put the AoT related configurations and generated code in a separate module called AppAoT . By default, skeleton applications include the zend-expressive-tooling component, which allows you to do this in a single step: $ ./vendor/bin/expressive module:create AppAoT If the tooling is present and the above command is successful, you can now skip to the next step. Otherwise, continue on to manually create your module. First, create the initial directory structure: $ mkdir src/AppAoT/src Next, create a config provider class in src/AppAoT/src/ConfigProvider.php : namespace AppAoT; class ConfigProvider { public function __invoke() { return [ 'dependencies' => $this->getDependencies(), ]; } public function getDependencies() { return [ 'auto' => [ 'aot' => [ 'namespace' => __NAMESPACE__ . '\\\\Generated', 'directory' => __DIR__ . '/../gen', ], ], ]; } } Add this new class to the the beginning of your config/config.php file's ConfigAggregator settings: $aggregator = new ConfigAggregator([ \\AppAoT\\ConfigProvider::class // Add Zend\\Di \\Zend\\Di\\ConfigProvider::class, // ... ]); In order for your application to find this class, we need to add an autoloading rule. Find the psr-4 autoloader section of your composer.json , and add an entry for your new AppAot namespace as follows: { \"autoload\": { \"psr-4\": { \"App\\\\\": \"src/App/src/\", \"AppAoT\\\\\": \"src/AppAoT/src/\", \"AppAoT\\\\Generated\\\\\": \"src/AppAoT/gen/\" } }, ... } Note that we defined AppAoT\\\\Generated\\\\ which will point to the code we generate from zend-di in the next steps. Finally, update your autoloader: $ composer dump-autoload","title":"2. Make your project ready for AoT"},{"location":"cookbook/aot-guide/#3-add-some-auto-wiring","text":"Because zend-di can provide autowiring for us, we can remove configuration that already exists within our App module. Edit the file src/App/src/ConfigProvider.php and comment out the entries shown below: public function getDependencies() { return [ 'invokables' => [ // Action\\PingAction::class => Action\\PingAction::class, ], 'factories' => [ // Action\\HomePageAction::class => Action\\HomePageFactory::class, ], ]; } We can also now remove the HomePageFactory referenced in that method: $ rm src/App/src/HomePageFactory.php The default actions ( HomePageAction and PingAction ) now use auto wiring!","title":"3. Add some auto-wiring"},{"location":"cookbook/aot-guide/#4-add-a-code-generator-command-script","text":"We will now add a simple script in the bin/ directory, which we will also add to our composer.json scripts section, to generate factories. In the real world, you might use a console implementation such as symfony/console for scripts such as these. Add the generator script bin/di-generate-aot.php : namespace AppAoT; use Psr\\Container\\ContainerInterface; use Zend\\Code\\Scanner\\DirectoryScanner; use Zend\\Di\\CodeGenerator\\InjectorGenerator; use Zend\\Di\\Config; require __DIR__ . '/../vendor/autoload.php'; // Define the source directories to scan for classes for which // to generate AoT factories: $directories = [ __DIR__ . '/../src/App/src', ]; /** @var ContainerInterface $container */ $container = require __DIR__ . '/../config/container.php'; $scanner = new DirectoryScanner($directories); $generator = $container->get(InjectorGenerator::class); $generator->generate($scanner->getClassNames());","title":"4. Add a code generator command script"},{"location":"cookbook/aot-guide/#5-add-aot-to-the-service-manager","text":"Now we need to make the service manager use the AoT code. First, we'll create a delegate factory to decorate the DI injector with the AoT version. Decorating the injector ensures that your factories that utilize Zend\\Di\\Container\\AutowireFactory will benefit from AoT as well. Create the file src/AppAoT/src/InjectorDecoratorFactory.php with the following contents: namespace AppAoT; use AppAoT\\Generated\\GeneratedInjector; use Interop\\Container\\ContainerInterface; use Zend\\ServiceManager\\Factory\\DelegatorFactoryInterface; class InjectorDecoratorFactory implements DelegatorFactoryInterface { public function __invoke(ContainerInterface $container, $name, callable $callback, array $options = null) { $injector = $callback(); if (class_exists(GeneratedInjector::class)) { return new GeneratedInjector($injector); } return $injector; } } After this we need to add configuration to the ConfigProvider class we created in step 2: Important: After this step, the application will always use the generated factories, if present. If you change any dependencies, you will need to run composer di-aot-generation again, or remove the generated code in src/AppAoT/gen/ and use runtime wiring. namespace AppAoT; use Zend\\Di\\InjectorInterface; class ConfigProvider { public function __invoke() { return [ 'dependencies' => $this->getDependencies(), ]; } public function getDependencies() { return [ 'auto' => [ 'aot' => [ 'namespace' => __NAMESPACE__ . '\\\\Generated', 'directory' => __DIR__ . '/../gen', ], ], 'factories' => $this->getGeneratedFactories(), 'delegators' => [ InjectorInterface::class => [ InjectorDecoratorFactory::class, ], ], ]; } private function getGeneratedFactories() { // The generated factories.php file is compatible with // zend-servicemanager's factory configuration. // This avoids using the abstract AutowireFactory, which // improves performance a bit since we spare some lookups. if (file_exists(__DIR__ . '/../gen/factories.php')) { return include __DIR__ . '/../gen/factories.php'; } return []; } }","title":"5. Add AoT to the service manager"},{"location":"cookbook/use-with-psr-containers/","text":"Usage with PSR-11 containers zend-di is designed to utilize and work with any IoC container thet implements the PSR-11 Psr\\Container\\ContainerInterface . To achieve this you can pass any container instance as the second parameter to the injector: use Zend\\Di\\Injector; $injector = new Injector(null, $container); From that point forwards, the injector will use the provided $container to obtain the dependencies. Decorating the container In the example above, the provided container may not utilize the injector to create unknown instances, even when the classes are known to zend-di. It may fail with an exception that dependencies could not be resolved. If you want to pair the container with the injector and use the injector for dependencies the container it is not aware of, you may decorate the original container into a zend-di-aware implementation. As an example: namespace MyApp; use Zend\\Di\\Injector; use Psr\\Container\\ContainerInterface; class MyContainer implements ContainerInterface { private $container; private $injector; public function __construct(ContainerInterface $container) { $this->container = $wrappedContainer; $this->injector = new Injector(null, $this); } public function has($name) { retrun $this->container->has($name) || $this->injector->canCreate($name); } public function get($name) { if ($this->container->has($name)) { return $this->container->get($name); } $service = $this->injector->create($name); // You might make the service shared via the decorated container // as well: // $this->container->set($name, $service); return $service; } }","title":"Usage with PSR-11 Containers"},{"location":"cookbook/use-with-psr-containers/#usage-with-psr-11-containers","text":"zend-di is designed to utilize and work with any IoC container thet implements the PSR-11 Psr\\Container\\ContainerInterface . To achieve this you can pass any container instance as the second parameter to the injector: use Zend\\Di\\Injector; $injector = new Injector(null, $container); From that point forwards, the injector will use the provided $container to obtain the dependencies.","title":"Usage with PSR-11 containers"},{"location":"cookbook/use-with-psr-containers/#decorating-the-container","text":"In the example above, the provided container may not utilize the injector to create unknown instances, even when the classes are known to zend-di. It may fail with an exception that dependencies could not be resolved. If you want to pair the container with the injector and use the injector for dependencies the container it is not aware of, you may decorate the original container into a zend-di-aware implementation. As an example: namespace MyApp; use Zend\\Di\\Injector; use Psr\\Container\\ContainerInterface; class MyContainer implements ContainerInterface { private $container; private $injector; public function __construct(ContainerInterface $container) { $this->container = $wrappedContainer; $this->injector = new Injector(null, $this); } public function has($name) { retrun $this->container->has($name) || $this->injector->canCreate($name); } public function get($name) { if ($this->container->has($name)) { return $this->container->get($name); } $service = $this->injector->create($name); // You might make the service shared via the decorated container // as well: // $this->container->set($name, $service); return $service; } }","title":"Decorating the container"},{"location":"cookbook/use-with-servicemanager/","text":"Usage With zend-servicemanager zend-di is designed to play and integrate well with zend-servicemanager. When you are using zend-component-installer , you just need to install zend-di via composer and you're done. Service Factories For DI instances zend-di ships with two service factories to provide the Zend\\Di\\InjectorInterface implementation. Zend\\Di\\Container\\ConfigFactory : Creates a config instance by using the \"config\" service. Zend\\Di\\Container\\InjectorFactory : Creates the injector instance that uses a Zend\\Di\\ConfigInterface service, if available. use Zend\\Di; use Zend\\Di\\Container; $serviceManager->setFactory(Di\\ConfigInterface::class, Container\\ConfigFactory::class); $serviceManager->setFactory(Di\\InjectorInterface::class, Container\\InjectorFactory::class); Abstract/Generic Service Factory This component ships with an generic factory Zend\\Di\\Container\\AutowireFactory . This factory is suitable as an abstract service factory for use with zend-servicemanager. You can also use it to create instances with zend-di using an IoC container (e.g. inside a service factory): use Zend\\Di\\Container\\AutowireFactory; (new AutowireFactory())->__invoke($container, MyClassname::class); Or you can use it as factory in your service configuration directly: return [ 'factories' => [ SomeClass::class => \\Zend\\Di\\Container\\AutowireFactory::class, ], ]; Service Factory For AoT Code Generation zend-di also provides a factory for Zend\\Di\\CodeGenerator\\InjectorGenerator . This factory ( Zend\\Di\\Container\\GeneratorFactory ) is also auto registered by the Module and ConfigProvider classes for zend-mvc and Expressive.","title":"Usage with zend-servicemanager"},{"location":"cookbook/use-with-servicemanager/#usage-with-zend-servicemanager","text":"zend-di is designed to play and integrate well with zend-servicemanager. When you are using zend-component-installer , you just need to install zend-di via composer and you're done.","title":"Usage With zend-servicemanager"},{"location":"cookbook/use-with-servicemanager/#service-factories-for-di-instances","text":"zend-di ships with two service factories to provide the Zend\\Di\\InjectorInterface implementation. Zend\\Di\\Container\\ConfigFactory : Creates a config instance by using the \"config\" service. Zend\\Di\\Container\\InjectorFactory : Creates the injector instance that uses a Zend\\Di\\ConfigInterface service, if available. use Zend\\Di; use Zend\\Di\\Container; $serviceManager->setFactory(Di\\ConfigInterface::class, Container\\ConfigFactory::class); $serviceManager->setFactory(Di\\InjectorInterface::class, Container\\InjectorFactory::class);","title":"Service Factories For DI instances"},{"location":"cookbook/use-with-servicemanager/#abstractgeneric-service-factory","text":"This component ships with an generic factory Zend\\Di\\Container\\AutowireFactory . This factory is suitable as an abstract service factory for use with zend-servicemanager. You can also use it to create instances with zend-di using an IoC container (e.g. inside a service factory): use Zend\\Di\\Container\\AutowireFactory; (new AutowireFactory())->__invoke($container, MyClassname::class); Or you can use it as factory in your service configuration directly: return [ 'factories' => [ SomeClass::class => \\Zend\\Di\\Container\\AutowireFactory::class, ], ];","title":"Abstract/Generic Service Factory"},{"location":"cookbook/use-with-servicemanager/#service-factory-for-aot-code-generation","text":"zend-di also provides a factory for Zend\\Di\\CodeGenerator\\InjectorGenerator . This factory ( Zend\\Di\\Container\\GeneratorFactory ) is also auto registered by the Module and ConfigProvider classes for zend-mvc and Expressive.","title":"Service Factory For AoT Code Generation"},{"location":"v2/config/","text":"Configuration Version 2 This is documentation for the legacy version (2.x) of zend-di. Most of the configuration for both the setup of Definition s as well as the setup of the InstanceManager can be attained by a configuration file. This file will produce an array (typically) and have an iterable structure. The top two keys are 'definition' and 'instance', each specifying values for the definition setup and instance manager setup, respectively. The definition section expects the following information expressed as a PHP array: $config = [ 'definition' => [ 'compiler' => [/* @todo compiler information */], 'runtime' => [/* @todo runtime information */], 'class' => [ 'instantiator' => '', // the name of the instantiator, by default this is __construct 'supertypes' => [], // an array of supertypes the class implements 'methods' => [ 'setSomeParameter' => [ // a method name 'parameterName' => [ 'name', // string parameter name 'type', // type or null 'is-required', // bool ], ], ], ], ], ];","title":"Configuration"},{"location":"v2/config/#configuration","text":"","title":"Configuration"},{"location":"v2/debugging-and-complex-use-cases/","text":"Debugging & Complex Use Cases Version 2 This is documentation for the legacy version (2.x) of zend-di. Debugging a DiC It is possible to dump the information contained within both the Definition and InstanceManager for a Zend\\Di\\Di instance. The easiest way is to do the following: Zend\\Di\\Display\\Console::export($di); If you are using a RuntimeDefinition where upon you expect a particular definition to be resolve at the first-call, you can see that information to the console display to force it to read that class: Zend\\Di\\Display\\Console::export($di, ['A\\ClassIWantTo\\GetTheDefinitionFor']); Complex Use Cases Interface Injection namespace Foo\\Bar { class Baz implements BamAwareInterface { public $bam; public function setBam(Bam $bam) { $this->bam = $bam; } } class Bam { } interface BamAwareInterface { public function setBam(Bam $bam); } } namespace { include 'zf2bootstrap.php'; $di = new Zend\\Di\\Di; $baz = $di->get('Foo\\Bar\\Baz'); } Setter Injection with Class Definition namespace Foo\\Bar { class Baz { public $bam; public function setBam(Bam $bam) { $this->bam = $bam; } } class Bam { } } namespace { $di = new Zend\\Di\\Di; $di->configure(new Zend\\Di\\Config([ 'definition' => [ 'class' => [ 'Foo\\Bar\\Baz' => [ 'setBam' => ['required' => true], ], ], ], ])); $baz = $di->get('Foo\\Bar\\Baz'); } Multiple Injections To A Single Injection Point namespace Application { class Page { public $blocks; public function addBlock(Block $block) { $this->blocks[] = $block; } } interface Block { } } namespace MyModule { class BlockOne implements \\Application\\Block {} class BlockTwo implements \\Application\\Block {} } namespace { include 'zf2bootstrap.php'; $di = new Zend\\Di\\Di; $di->configure(new Zend\\Di\\Config([ 'definition' => [ 'class' => [ 'Application\\Page' => [ 'addBlock' => [ 'block' => [ 'type' => 'Application\\Block', 'required' => true, ], ], ], ], ], 'instance' => [ 'Application\\Page' => [ 'injections' => [ 'MyModule\\BlockOne', 'MyModule\\BlockTwo', ], ], ], ])); $page = $di->get('Application\\Page'); }","title":"Debugging And Complex Use Cases"},{"location":"v2/debugging-and-complex-use-cases/#debugging-complex-use-cases","text":"","title":"Debugging &amp; Complex Use Cases"},{"location":"v2/debugging-and-complex-use-cases/#debugging-a-dic","text":"It is possible to dump the information contained within both the Definition and InstanceManager for a Zend\\Di\\Di instance. The easiest way is to do the following: Zend\\Di\\Display\\Console::export($di); If you are using a RuntimeDefinition where upon you expect a particular definition to be resolve at the first-call, you can see that information to the console display to force it to read that class: Zend\\Di\\Display\\Console::export($di, ['A\\ClassIWantTo\\GetTheDefinitionFor']);","title":"Debugging a DiC"},{"location":"v2/debugging-and-complex-use-cases/#complex-use-cases","text":"","title":"Complex Use Cases"},{"location":"v2/definitions/","text":"Dependency Definitions Version 2 This is documentation for the legacy version (2.x) of zend-di. Definitions are what zend-di uses to understand the structure of the code it is attempting to wire. This means that if you've written non-ambiguous, clear, and concise code, zend-di has a very good chance of understanding how to wire things up without much added complexity. DefinitionList Definitions are introduced to the Zend\\Di\\Di object through a definition list implemented as Zend\\Di\\DefinitionList (which extends SplDoublyLinkedList ). Order is important. Definitions in the front of the list will be consulted on a class before definitions at the end of the list. Autoloading Regardless of what kind of DefinitionList strategy you decide to use, it is important that your autoloaders are already setup and ready to use. RuntimeDefinition The default DefinitionList instantiated by Zend\\Di\\Di when no other DefinitionList is provided is Zend\\Di\\Definition\\RuntimeDefinition . The RuntimeDefinition will respond to queries about classes by using PHP's Reflection API. The RuntimeDefinition uses any available information inside methods \u2014 including their signature, the names of parameters, the type-hints of the parameters, and the default values \u2014 to determine if something is optional or required when making a call to that method. The more explicit you can be in your method naming and method signatures, the more likely Zend\\Di\\Definition\\RuntimeDefinition will accurately understand the structure of your code. The constructor of RuntimeDefinition looks like the following: public function __construct( IntrospectionStrategy $introspectionStrategy = null, array $explicitClasses = null ) { $this->introspectionStrategy = $introspectionStrategy ?: new IntrospectionStrategy(); if ($explicitClasses) { $this->setExplicitClasses($explicitClasses); } } The IntrospectionStrategy object is an object that defines the rules by which the RuntimeDefinition will introspect information about your classes. Here are the things it knows how to do: Whether or not to use annotations (scanning and parsing annotations is expensive, and thus disabled by default). Which method names to include in the introspection; this is a list of patterns. By default, it registers the pattern /^set\\[A-Z\\]{1}\\\\w\\*/ . Which interface names represent the interface injection pattern; this is a list of patterns. By default, the pattern /\\\\w\\*Aware\\\\w\\*/ is registered. The constructor for the IntrospectionStrategy looks like this: public function __construct(AnnotationManager $annotationManager = null) { $this->annotationManager = $annotationManager ?: $this->createDefaultAnnotationManager(); } The AnnotationManager is not required. If you wish to create a special AnnotationManager with your own annotations, and also wish to extend the RuntimeDefinition to look for those annotations, this is the place to do it. The RuntimeDefinition also can be used to look up either all classes (implicitly, which is default), or explicitly look up for particular pre-defined classes. This is useful when your strategy for inspecting one set of classes might differ from those of another strategy for another set of classes. This can be achieved by using the setExplicitClasses() method or by passing a list of classes as the second constructor argument of the RuntimeDefinition . CompilerDefinition The CompilerDefinition is similar in nature to the RuntimeDefinition with the exception that it can be seeded with more information for the purposes of \"compiling\" a definition. Compiled definitions eliminate reflection calls and annotation scannning, which can be a performance bottleneck in your production applications. For example, let's assume we want to create a script that will create definitions for some of our library code: // in \"package name\" format $components = [ 'My_MovieApp', 'My_OtherClasses', ]; foreach ($components as $component) { $diCompiler = new Zend\\Di\\Definition\\CompilerDefinition; $diCompiler->addDirectory('/path/to/classes/' . str_replace('_', '/', $component)); $diCompiler->compile(); file_put_contents( __DIR__ . '/../data/di/' . $component . '-definition.php', '<?php return ' . var_export($diCompiler->toArrayDefinition()->toArray(), true) . ';' ); } The above creates a file for each \"package\", containing the full definition for the classes defined for each. To utilize this in an application, use the following: protected function setupDi(Application $app) { $definitionList = new DefinitionList([ new Definition\\ArrayDefinition(include __DIR__ . '/path/to/data/di/My_MovieApp-definition.php'), new Definition\\ArrayDefinition(include __DIR__ . '/path/to/data/di/My_OtherClasses-definition.php'), $runtime = new Definition\\RuntimeDefinition(), ]); $di = new Di($definitionList, null, new Config($this->config->di)); $di->instanceManager()->addTypePreference('Zend\\Di\\LocatorInterface', $di); $app->setLocator($di); } The above code would more than likely go inside your application's bootstrap or within a Module class. This represents the simplest and most performant way of configuring your DiC for usage. ClassDefinition The idea behind using a ClassDefinition is two-fold. First, you may want to override some information inside of a RuntimeDefinition . Secondly, you might want to simply define your complete class's definition with an xml, ini, or php file describing the structure. This class definition can be fed in via Configuration or by directly instantiating and registering the Definition with the DefinitionList .","title":"Dependency Definitions"},{"location":"v2/definitions/#dependency-definitions","text":"","title":"Dependency Definitions"},{"location":"v2/definitions/#definitionlist","text":"Definitions are introduced to the Zend\\Di\\Di object through a definition list implemented as Zend\\Di\\DefinitionList (which extends SplDoublyLinkedList ). Order is important. Definitions in the front of the list will be consulted on a class before definitions at the end of the list.","title":"DefinitionList"},{"location":"v2/definitions/#runtimedefinition","text":"The default DefinitionList instantiated by Zend\\Di\\Di when no other DefinitionList is provided is Zend\\Di\\Definition\\RuntimeDefinition . The RuntimeDefinition will respond to queries about classes by using PHP's Reflection API. The RuntimeDefinition uses any available information inside methods \u2014 including their signature, the names of parameters, the type-hints of the parameters, and the default values \u2014 to determine if something is optional or required when making a call to that method. The more explicit you can be in your method naming and method signatures, the more likely Zend\\Di\\Definition\\RuntimeDefinition will accurately understand the structure of your code. The constructor of RuntimeDefinition looks like the following: public function __construct( IntrospectionStrategy $introspectionStrategy = null, array $explicitClasses = null ) { $this->introspectionStrategy = $introspectionStrategy ?: new IntrospectionStrategy(); if ($explicitClasses) { $this->setExplicitClasses($explicitClasses); } } The IntrospectionStrategy object is an object that defines the rules by which the RuntimeDefinition will introspect information about your classes. Here are the things it knows how to do: Whether or not to use annotations (scanning and parsing annotations is expensive, and thus disabled by default). Which method names to include in the introspection; this is a list of patterns. By default, it registers the pattern /^set\\[A-Z\\]{1}\\\\w\\*/ . Which interface names represent the interface injection pattern; this is a list of patterns. By default, the pattern /\\\\w\\*Aware\\\\w\\*/ is registered. The constructor for the IntrospectionStrategy looks like this: public function __construct(AnnotationManager $annotationManager = null) { $this->annotationManager = $annotationManager ?: $this->createDefaultAnnotationManager(); } The AnnotationManager is not required. If you wish to create a special AnnotationManager with your own annotations, and also wish to extend the RuntimeDefinition to look for those annotations, this is the place to do it. The RuntimeDefinition also can be used to look up either all classes (implicitly, which is default), or explicitly look up for particular pre-defined classes. This is useful when your strategy for inspecting one set of classes might differ from those of another strategy for another set of classes. This can be achieved by using the setExplicitClasses() method or by passing a list of classes as the second constructor argument of the RuntimeDefinition .","title":"RuntimeDefinition"},{"location":"v2/definitions/#compilerdefinition","text":"The CompilerDefinition is similar in nature to the RuntimeDefinition with the exception that it can be seeded with more information for the purposes of \"compiling\" a definition. Compiled definitions eliminate reflection calls and annotation scannning, which can be a performance bottleneck in your production applications. For example, let's assume we want to create a script that will create definitions for some of our library code: // in \"package name\" format $components = [ 'My_MovieApp', 'My_OtherClasses', ]; foreach ($components as $component) { $diCompiler = new Zend\\Di\\Definition\\CompilerDefinition; $diCompiler->addDirectory('/path/to/classes/' . str_replace('_', '/', $component)); $diCompiler->compile(); file_put_contents( __DIR__ . '/../data/di/' . $component . '-definition.php', '<?php return ' . var_export($diCompiler->toArrayDefinition()->toArray(), true) . ';' ); } The above creates a file for each \"package\", containing the full definition for the classes defined for each. To utilize this in an application, use the following: protected function setupDi(Application $app) { $definitionList = new DefinitionList([ new Definition\\ArrayDefinition(include __DIR__ . '/path/to/data/di/My_MovieApp-definition.php'), new Definition\\ArrayDefinition(include __DIR__ . '/path/to/data/di/My_OtherClasses-definition.php'), $runtime = new Definition\\RuntimeDefinition(), ]); $di = new Di($definitionList, null, new Config($this->config->di)); $di->instanceManager()->addTypePreference('Zend\\Di\\LocatorInterface', $di); $app->setLocator($di); } The above code would more than likely go inside your application's bootstrap or within a Module class. This represents the simplest and most performant way of configuring your DiC for usage.","title":"CompilerDefinition"},{"location":"v2/definitions/#classdefinition","text":"The idea behind using a ClassDefinition is two-fold. First, you may want to override some information inside of a RuntimeDefinition . Secondly, you might want to simply define your complete class's definition with an xml, ini, or php file describing the structure. This class definition can be fed in via Configuration or by directly instantiating and registering the Definition with the DefinitionList .","title":"ClassDefinition"},{"location":"v2/instance-manager/","text":"Instance Manager Version 2 This is documentation for the legacy version (2.x) of zend-di. The InstanceManager is responsible for any runtime information associated with the zend-di DiC. This means that the information that goes into the instance manager is specific to both how the particular consuming application's needs, and even more specifically to the environment in which the application is running. Parameters Parameters are simply entry points for either dependencies or instance configuration values. A class consists of a set of parameters, each uniquely named. When writing your classes, you should attempt to not use the same parameter name twice in the same class when you expect that that parameters is used for either instance configuration or an object dependency. This leads to an ambiguous parameter, and is a situation best avoided. Our movie finder example can be further used to explain these concepts: namespace MyLibrary { class DbAdapter { protected $username = null; protected $password = null; public function __construct($username, $password) { $this->username = $username; $this->password = $password; } } } namespace MyMovieApp { class MovieFinder { protected $dbAdapter = null; public function __construct(\\MyLibrary\\DbAdapter $dbAdapter) { $this->dbAdapter = $dbAdapter; } } class MovieLister { protected $movieFinder = null; public function __construct(MovieFinder $movieFinder) { $this->movieFinder = $movieFinder; } } } In the above example, the class DbAdapter has 2 parameters: username and password ; MovieFinder has one parameter: dbAdapter ; and MovieLister has one parameter: movieFinder . Any of these can be utilized for injection of either dependencies or scalar values during instance configuration or during call time. When looking at the above code, since the $dbAdapter parameter and the $movieFinder parameter are both type-hinted with concrete types, the DiC can assume that it can fulfill these object tendencies by itself. On the other hand, $username and $password do not have type-hints and are, more than likely, scalar in nature. Since the DiC cannot reasonably know this information, it must be provided to the instance manager in the form of parameters. Not doing so will force $di->get('MyMovieApp\\\\MovieLister') to throw an exception. The following ways of using parameters are available: // Setting instance configuration into the instance manager: $di->instanceManager()->setParameters('MyLibrary\\DbAdapter', [ 'username' => 'myusername', 'password' => 'mypassword', ]); // Forcing a particular dependency to be used by the instance manager: $di->instanceManager()->setParameters('MyMovieApp\\MovieFinder', [ 'dbAdapter' => new MyLibrary\\DbAdapter('myusername', 'mypassword'), ]); // Passing instance parameters at call time: $movieLister = $di->get('MyMovieApp\\MovieLister', [ 'username' => $config->username, 'password' => $config->password, ]); // Passing a specific instance at call time: $movieLister = $di->get('MyMovieApp\\MovieLister', [ 'dbAdapter' => new MyLibrary\\DbAdapter('myusername', 'mypassword'), ]); Preferences In many cases, you might be using interfaces as type hints as opposed to concrete types. Lets assume the movie example was modified in the following way: namespace MyMovieApp { interface MovieFinderInterface { // methods required for this type } class GenericMovieFinder implements MovieFinderInterface { protected $dbAdapter = null; public function __construct(\\MyLibrary\\DbAdapter $dbAdapter) { $this->dbAdapter = $dbAdapter; } } class MovieLister { protected $movieFinder = null; public function __construct(MovieFinderInterface $movieFinder) { $this->movieFinder = $movieFinder; } } } What you'll notice above is that the MovieLister type now expects that the dependency injected implements the MovieFinderInterface . This allows multiple implementations of this base interface to be used as a dependency, if that is what the consumer decides they want to do. As you can imagine, zend-di, by itself would not be able to determine what kind of concrete object to use fulfill this dependency, so this type of \"preference\" needs to be made known to the instance manager. To give this information to the instance manager, see the following code example: $di->instanceManager()->addTypePreference( \\MyMovieApp\\MovieFinderInterface::class, \\MyMovieApp\\GenericMovieFinder::class ); // Assuming all instance config for username, password is setup: $di->get(\\MyMovieApp\\MovieLister::class); Aliases In some situations, you'll find that you need to alias an instance. There are two main reasons to do this. First, it creates a simpler, alternative name to use when using the DiC, as opposed to using the full class name. Second, you might find that you need to have the same object type in two separate contexts. This means that when you alias a particular class, you can then attach a specific instance configuration to that alias, as opposed to attaching that configuration to the class name. To demonstrate both of these points, we'll look at a use case where we'll have two separate database adapters. One will be for read-only operations, the other will be for read-write operations. Alias parameters Aliases can also have parameters registered at alias time. // Assume the MovieLister example of code from the quick start. $im = $di->instanceManager(); // add alias for short naming $im->addAlias('movielister', 'MyMovieApp\\MovieLister'); // add aliases for specific instances $im->addAlias('dbadapter-readonly', 'MyLibrary\\DbAdapter', [ 'username' => $config->db->readAdapter->username, 'password' => $config->db->readAdapter->password, ]); $im->addAlias('dbadapter-readwrite', 'MyLibrary\\DbAdapter', [ 'username' => $config->db->readWriteAdapter->username, 'password' => $config->db->readWriteAdapter->password, ]); // set a default type to use, pointing to an alias $im->addTypePreference('MyLibrary\\DbAdapter', 'dbadapter-readonly'); $movieListerRead = $di->get('MyMovieApp\\MovieLister'); $movieListerReadWrite = $di->get('MyMovieApp\\MovieLister', [ 'dbAdapter' => 'dbadapter-readwrite', ]);","title":"Instance Manager"},{"location":"v2/instance-manager/#instance-manager","text":"","title":"Instance Manager"},{"location":"v2/instance-manager/#parameters","text":"Parameters are simply entry points for either dependencies or instance configuration values. A class consists of a set of parameters, each uniquely named. When writing your classes, you should attempt to not use the same parameter name twice in the same class when you expect that that parameters is used for either instance configuration or an object dependency. This leads to an ambiguous parameter, and is a situation best avoided. Our movie finder example can be further used to explain these concepts: namespace MyLibrary { class DbAdapter { protected $username = null; protected $password = null; public function __construct($username, $password) { $this->username = $username; $this->password = $password; } } } namespace MyMovieApp { class MovieFinder { protected $dbAdapter = null; public function __construct(\\MyLibrary\\DbAdapter $dbAdapter) { $this->dbAdapter = $dbAdapter; } } class MovieLister { protected $movieFinder = null; public function __construct(MovieFinder $movieFinder) { $this->movieFinder = $movieFinder; } } } In the above example, the class DbAdapter has 2 parameters: username and password ; MovieFinder has one parameter: dbAdapter ; and MovieLister has one parameter: movieFinder . Any of these can be utilized for injection of either dependencies or scalar values during instance configuration or during call time. When looking at the above code, since the $dbAdapter parameter and the $movieFinder parameter are both type-hinted with concrete types, the DiC can assume that it can fulfill these object tendencies by itself. On the other hand, $username and $password do not have type-hints and are, more than likely, scalar in nature. Since the DiC cannot reasonably know this information, it must be provided to the instance manager in the form of parameters. Not doing so will force $di->get('MyMovieApp\\\\MovieLister') to throw an exception. The following ways of using parameters are available: // Setting instance configuration into the instance manager: $di->instanceManager()->setParameters('MyLibrary\\DbAdapter', [ 'username' => 'myusername', 'password' => 'mypassword', ]); // Forcing a particular dependency to be used by the instance manager: $di->instanceManager()->setParameters('MyMovieApp\\MovieFinder', [ 'dbAdapter' => new MyLibrary\\DbAdapter('myusername', 'mypassword'), ]); // Passing instance parameters at call time: $movieLister = $di->get('MyMovieApp\\MovieLister', [ 'username' => $config->username, 'password' => $config->password, ]); // Passing a specific instance at call time: $movieLister = $di->get('MyMovieApp\\MovieLister', [ 'dbAdapter' => new MyLibrary\\DbAdapter('myusername', 'mypassword'), ]);","title":"Parameters"},{"location":"v2/instance-manager/#preferences","text":"In many cases, you might be using interfaces as type hints as opposed to concrete types. Lets assume the movie example was modified in the following way: namespace MyMovieApp { interface MovieFinderInterface { // methods required for this type } class GenericMovieFinder implements MovieFinderInterface { protected $dbAdapter = null; public function __construct(\\MyLibrary\\DbAdapter $dbAdapter) { $this->dbAdapter = $dbAdapter; } } class MovieLister { protected $movieFinder = null; public function __construct(MovieFinderInterface $movieFinder) { $this->movieFinder = $movieFinder; } } } What you'll notice above is that the MovieLister type now expects that the dependency injected implements the MovieFinderInterface . This allows multiple implementations of this base interface to be used as a dependency, if that is what the consumer decides they want to do. As you can imagine, zend-di, by itself would not be able to determine what kind of concrete object to use fulfill this dependency, so this type of \"preference\" needs to be made known to the instance manager. To give this information to the instance manager, see the following code example: $di->instanceManager()->addTypePreference( \\MyMovieApp\\MovieFinderInterface::class, \\MyMovieApp\\GenericMovieFinder::class ); // Assuming all instance config for username, password is setup: $di->get(\\MyMovieApp\\MovieLister::class);","title":"Preferences"},{"location":"v2/instance-manager/#aliases","text":"In some situations, you'll find that you need to alias an instance. There are two main reasons to do this. First, it creates a simpler, alternative name to use when using the DiC, as opposed to using the full class name. Second, you might find that you need to have the same object type in two separate contexts. This means that when you alias a particular class, you can then attach a specific instance configuration to that alias, as opposed to attaching that configuration to the class name. To demonstrate both of these points, we'll look at a use case where we'll have two separate database adapters. One will be for read-only operations, the other will be for read-write operations.","title":"Aliases"}]}